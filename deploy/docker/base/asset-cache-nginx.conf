worker_processes auto;
worker_rlimit_nofile 65535;

events {
  multi_accept on;
  worker_connections 1024;
  # Note: epoll (Linux) or kqueue (macOS) is auto-selected by nginx
}

http {
  server_tokens off;
  sendfile on;
  tcp_nopush on;
  tcp_nodelay on;

  # DNS resolver - Docker internal DNS (127.0.0.11) or dynamically set for local dev
  resolver 127.0.0.11 valid=10s ipv6=off;

  # Cache configuration
  # keys_zone: 32m = ~256k cache keys (each key ~128 bytes metadata)
  # max_size: 450m = leave headroom for nginx processes and buffers
  # inactive: 10m = evict unused entries after 10 minutes (middle ground)
  # manager settings: process more files per iteration for faster eviction
  proxy_cache_path /tmp/nginx/cache levels=1:2 keys_zone=asset_cache:32m max_size=450m inactive=10m use_temp_path=off loader_threshold=300 loader_files=200 manager_files=1000 manager_threshold=200 manager_sleep=30;
  proxy_cache_key "$request_method|$scheme|$proxy_host|$request_uri|$request_body";
  proxy_cache_min_uses 1;
  proxy_cache_lock on;
  proxy_cache_lock_timeout 5s;
  proxy_cache_lock_age 10s;
  proxy_cache_use_stale error timeout invalid_header updating http_500 http_502 http_503 http_504;
  proxy_cache_background_update on;
  proxy_cache_revalidate on;

  # Cache behavior defaults (0 = false, so caching is enabled)
  proxy_no_cache 0;      # 0 = do cache (do not disable caching)
  proxy_cache_bypass 0;  # 0 = use cache (do not bypass)

  # Set timeouts for upstream connections
  proxy_connect_timeout 5s;
  proxy_send_timeout 60s;  # Increased for large request bodies
  proxy_read_timeout 120s; # Increased for large responses

  # Buffer settings to control memory usage
  proxy_buffering on;
  proxy_buffer_size 16k;
  proxy_buffers 8 16k;  # 128k total per connection
  proxy_busy_buffers_size 32k;
  proxy_max_temp_file_size 0;  # Disable temp files, keep everything in memory/cache

  # Retry connecting to upstream servers
  proxy_next_upstream error timeout http_500 http_502 http_503 http_504;
  proxy_next_upstream_timeout 10s;
  proxy_next_upstream_tries 3;

  log_format cache_log '$remote_addr - $remote_user [$time_local] "$request" '
                        '$status $body_bytes_sent "$http_referer" '
                        '"$http_user_agent" "$http_x_forwarded_for" '
                        'cache_status: $upstream_cache_status '
                        'rt=$request_time uct="$upstream_connect_time" uht="$upstream_header_time" urt="$upstream_response_time"';

  access_log /dev/stdout cache_log;

  server {
    listen 8000;

    # Use variable to force DNS re-resolution
    set $asset_backend "asset:8090";

    location ~ ^/api/v1/(subtree|subtree_data|block|blocks|header|headers|block_legacy|headers_to_common_ancestor|headers_from_common_ancestor)/([0-9a-fA-F]+)$ {
      # Try to use cache, but always fetch from backend if needed
      proxy_cache asset_cache;
      proxy_cache_valid 200 5m;
      proxy_cache_methods GET HEAD;
      proxy_ignore_headers Cache-Control Expires;

      # If cache lock times out, serve from backend anyway
      proxy_cache_lock_timeout 5s;

      proxy_pass http://$asset_backend;

      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;

      add_header X-Cache-Status $upstream_cache_status always;
      add_header Cache-Control "public, max-age=300" always;
    }

    location ~ ^/api/v1/(txs|subtree/[0-9a-fA-F]+/txs)$ {
      proxy_pass http://$asset_backend;

      # Explicitly disable caching for this endpoint
      proxy_no_cache 1;
      proxy_cache_bypass 1;

      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;

      add_header X-Cache-Status $upstream_cache_status;
      add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate";
      add_header Pragma "no-cache";
      add_header Expires "0";
    }

    # Block all other requests
    location / {
        return 404;
    }
  }
}
